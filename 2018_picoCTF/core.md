# core
Forensics, 350 points

## Description:
> This program was about to print the flag when it died. Maybe the flag is still in this core file that it dumped?


Attached were two binary file.

## Solution:

Let's open the core file with GDB:
```
root@kali:/media/sf_CTFs/pico/core# gdb print_flag core
GNU gdb (Debian 7.12-6+b1) 7.12.0.20161007-git
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from print_flag...done.
[New LWP 45278]

warning: .dynamic section for "/lib32/libc.so.6" is not at the expected address (wrong library or version mismatch?)

warning: .dynamic section for "/lib/ld-linux.so.2" is not at the expected address (wrong library or version mismatch?)
Core was generated by `/opt/hacksports/staging/core_0_6032849791073672/problem_files/print_flag'.
Program terminated with signal SIGTRAP, Trace/breakpoint trap.
#0  print_flag () at ./print_flag.c:90
90      ./print_flag.c: No such file or directory.
gdb-peda$
```

We don't have the sources, but we can inspect the backtrace:
```
gdb-peda$ bt
#0  print_flag () at ./print_flag.c:90
#1  0x08048807 in main () at ./print_flag.c:98
#2  0xf7e2e637 in ?? () from /lib32/libc.so.6
#3  0x0000000c in ?? ()
gdb-peda$
```

Let's disassemble `print_flag`:
```
gdb-peda$ disas print_flag
Dump of assembler code for function print_flag:
=> 0x080487c1 <+0>:     push   ebp
   0x080487c2 <+1>:     mov    ebp,esp
   0x080487c4 <+3>:     sub    esp,0x18
   0x080487c7 <+6>:     mov    DWORD PTR [ebp-0xc],0x539
   0x080487ce <+13>:    mov    eax,DWORD PTR [ebp-0xc]
   0x080487d1 <+16>:    mov    eax,DWORD PTR [eax*4+0x804a080]
   0x080487d8 <+23>:    sub    esp,0x8
   0x080487db <+26>:    push   eax
   0x080487dc <+27>:    push   0x804894c
   0x080487e1 <+32>:    call   0x8048410 <printf@plt>
   0x080487e6 <+37>:    add    esp,0x10
   0x080487e9 <+40>:    nop
   0x080487ea <+41>:    leave
   0x080487eb <+42>:    ret
End of assembler dump.
```

What would the program print here?
```assembly
   0x080487dc <+27>:    push   0x804894c
   0x080487e1 <+32>:    call   0x8048410 <printf@plt>
```

We can check what's at that offset:
```
gdb-peda$ hexdump 0x804894c
0x0804894c : 79 6f 75 72 20 66 6c 61 67 20 69 73 3a 20 70 69   your flag is: pi
```

Or, as a string:
```
gdb-peda$ printf "%s", 0x804894c
your flag is: picoCTF{%s}
```

So what we really want is pointed to by eax, after this calculation:
```
   0x080487c7 <+6>:	mov    DWORD PTR [ebp-0xc],0x539
   0x080487ce <+13>:	mov    eax,DWORD PTR [ebp-0xc]
   0x080487d1 <+16>:	mov    eax,DWORD PTR [eax*4+0x804a080]
```

Therefore:
```
gdb-peda$ p 0x539*4+0x804a080
$1 = 0x804b564
gdb-peda$ p *$1
$2 = 0x80610f0
gdb-peda$ printf "%s\n", $2
abb6a3b2603654804ed357322c760510
gdb-peda$ 
```

We can print the complete flag using an `eval` trick:
```
gdb-peda$ eval "printf \"%s\", $2", 0x804894c
your flag is: picoCTF{abb6a3b2603654804ed357322c760510}
```

What happens here is that first the `eval` turns the encapsulated command into `printf "picoCTF{%s}", $2`, and then the encapsulated command is executed, printing the full flag.
Note that the `%s` we entered is for `eval`'s use only. The flag is printed as a string because of the `%s` in the referenced address (`0x804894c` => `your flag is: picoCTF{%s}`).

The flag: picoCTF{abb6a3b2603654804ed357322c760510}